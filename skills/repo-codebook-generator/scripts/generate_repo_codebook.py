from __future__ import annotations

import re
import subprocess
from dataclasses import dataclass
from fnmatch import fnmatch
from pathlib import Path

OUTPUT_PATH = Path("docs/artifacts/repo_codebook.md")
TEMPLATE_PATH = Path("assets/templates/repo_codebook.md.tmpl")

# Extra exclusions beyond .gitignore (generated/build/runtime artifacts).
EXCLUDE_NAMES = {
    ".git",
    "__pycache__",
    ".venv",
    ".mypy_cache",
    ".ruff_cache",
    ".pytest_cache",
    "htmlcov",
    "tests",
    "docs/artifacts",
}
EXCLUDE_GLOBS = {
    "*.pyc",
    "*.egg-info",
    ".env",
    ".env.*",
    ".coverage",
    "uv.lock",
    ".python-version",
    ".dockerignore",
    ".gitignore",
    "docs/artifacts/*",
    "docs/artifacts/repo_codebook.md",
}

MAX_TEXT_FILE_BYTES = 512 * 1024  # 512 KB


@dataclass(frozen=True)
class ProjectInfo:
    name: str
    description_bullets: list[str]


_VERSION_RE = re.compile(r"^- all_docs_version:\s*([0-9]+)\.([0-9]+)\.([0-9]+)\s*$", re.MULTILINE)


def _run(cmd: list[str]) -> str:
    res = subprocess.run(cmd, check=True, capture_output=True, text=True)
    return res.stdout.rstrip("\n")


def _should_exclude(path: Path) -> bool:
    parts = set(path.parts)
    if any(p in EXCLUDE_NAMES for p in parts):
        return True

    p = path.as_posix()
    return any(fnmatch(p, pat) for pat in EXCLUDE_GLOBS)


def _is_binary_or_too_large(path: Path) -> bool:
    try:
        size = path.stat().st_size
    except OSError:
        return True

    if size > MAX_TEXT_FILE_BYTES:
        return True

    try:
        path.read_text(encoding="utf-8")
    except UnicodeDecodeError:
        return True

    return False


def _detect_language(path: Path) -> str:
    ext = path.suffix.lower()
    return {
        ".py": "python",
        ".toml": "toml",
        ".yaml": "yaml",
        ".yml": "yaml",
        ".json": "json",
        ".md": "md",
        ".sh": "bash",
        ".txt": "text",
    }.get(ext, "")


def _bump_patch_version(existing: str | None) -> str:
    if not existing:
        return "1.0.0"

    m = _VERSION_RE.search(existing)
    if not m:
        return "1.0.0"

    major, minor, patch = (int(m.group(1)), int(m.group(2)), int(m.group(3)))
    return f"{major}.{minor}.{patch + 1}"


def _project_info() -> ProjectInfo:
    # Heuristic: use repo folder name; optionally read README.md for bullets if present.
    repo_name = Path.cwd().name

    bullets: list[str] = []
    readme = Path("README.md")
    if readme.exists():
        lines = [ln.strip() for ln in readme.read_text(encoding="utf-8", errors="ignore").splitlines()]
        # Pick a few non-empty lines as a minimal baseline; user/agent can refine later.
        for ln in lines:
            if ln and not ln.startswith("#") and len(bullets) < 3:
                bullets.append(f"- {ln[:120]}")
    if not bullets:
        bullets = ["- Repository codebase (details generated by this codebook)."]

    return ProjectInfo(name=repo_name, description_bullets=bullets)


def _tree_output() -> str:
    # Use the same command as scripts/get_tree.sh to ensure parity.
    return _run(["bash", "scripts/get_tree.sh"])


def _file_list() -> list[Path]:
    # Tracked + untracked (not ignored), respecting .gitignore via --exclude-standard.
    raw = _run(["git", "ls-files", "-co", "--exclude-standard"])
    files = [Path(p) for p in raw.splitlines() if p.strip()]
    filtered: list[Path] = []
    for p in files:
        if not p.exists() or p.is_dir():
            continue
        if _should_exclude(p):
            continue
        filtered.append(p)
    return sorted(filtered, key=lambda x: x.as_posix())


def _one_line_description(path: Path) -> str:
    # Minimal heuristic; keep descriptions objective and <= 1 line.
    try:
        text = path.read_text(encoding="utf-8", errors="ignore")
    except OSError:
        return "Unreadable file."

    for ln in text.splitlines():
        s = ln.strip()
        if not s:
            continue
        # Prefer module docstring first line if present.
        if s.startswith('"""') or s.startswith("'''"):
            continue
        return s[:140]
    return "Empty file."


def _render_code_blocks(paths: list[Path]) -> str:
    blocks: list[str] = []
    for p in paths:
        if _is_binary_or_too_large(p):
            blocks.append(f"- `{p.as_posix()}`: skipped (binary or too large)\n")
            continue

        lang = _detect_language(p)
        content = p.read_text(encoding="utf-8")
        fence = f"```{lang}".rstrip()
        blocks.append(f"{fence}\n# {p.as_posix()}\n{content}\n```\n")

    return "\n".join(blocks).rstrip()


def _render_descriptions(paths: list[Path]) -> str:
    lines = [f"- `{p.as_posix()}`: {_one_line_description(p)}" for p in paths]
    return "\n".join(lines)


def main() -> int:
    OUTPUT_PATH.parent.mkdir(parents=True, exist_ok=True)

    existing = OUTPUT_PATH.read_text(encoding="utf-8") if OUTPUT_PATH.exists() else None
    version = _bump_patch_version(existing)

    info = _project_info()
    tree_out = _tree_output()
    paths = _file_list()

    tmpl = TEMPLATE_PATH.read_text(encoding="utf-8")
    out = tmpl
    out = out.replace("__PROJECT_NAME__", info.name)
    out = out.replace("__PROJECT_DESCRIPTION_BULLETS__", "\n".join(info.description_bullets))
    out = out.replace("__ALL_DOCS_VERSION__", version)
    out = out.replace("__TREE_OUTPUT__", tree_out)
    out = out.replace("__FILE_DESCRIPTIONS__", _render_descriptions(paths))
    out = out.replace("__FILE_CODE_BLOCKS__", _render_code_blocks(paths))

    OUTPUT_PATH.write_text(out + "\n", encoding="utf-8")
    return 0


if __name__ == "__main__":
    raise SystemExit(main())
